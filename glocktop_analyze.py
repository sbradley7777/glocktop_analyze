#!/usr/bin/python
# -*- coding: utf-8 -*-
"""This script analyzes output generated by glocktop for GFS2 filesystems.

- How can I view glock contention on a GFS2 filesystem in real-time in a
  RHEL 5, 6, or 7 Resilient Storage cluster?
  https://access.redhat.com/articles/666533
- Source Code gfs2-utils.git - glocktop
  https://git.fedorahosted.org/cgit/gfs2-utils.git/tree/gfs2/glocktop

@author    : Shane Bradley
@contact   : sbradley@redhat.com
@version   : 0.1
@copyright : GPLv3


Current TODO:
* Move the max_glocks_to_graph to graphs. Need to create a way to get smaller
  subset of data if data has over 100 or 200 snapshots. 8000 graph points takes forever
  * 10.
* Do i need to set as global var or some option for the var: max_glocks_to_graph


* Move stats to plugin setup. Go through snapshots once and create dict{}
  container for stats. Then pass the container to plugin. Each stat-plugin will
  take a dict{} and do work on it.

RFEs:
* Add remaining stat queries and stat tables like for pids, DLM.
* Create html pages for the summary, stats, everything instead of writing plain
  text to file.
* NEED OPTION: To disable_call_trace so call trace not printed. Still not
  parsing call_trace or U data.
* Warning on high demote_seconds, high waiter count, high DLM traffic.
* Could i combine the data into 1 file. Take 8 glocktops, then write to 1 file
  with everything sorted by date to see what is happenign on all nodes at around
  same time. Do not think a way to group cause started at different times and
  takes different times to print data.


RFEs for graphs:
* Need to figure out why glock_holder_waiters_count_over_time not plotting
 correctly and why not all y-axis is showing up.
* For graphs do not like how i am storing date/time and int in list for graphing.
* MAYBE NEED a GLOCK STAT OBEJECT to hold: hostname, filesname, date, glock,
 holder/waiter count, pids, demote_time.  Stuff like keeping up with
 glock-filesystem might get tricky and eventually parsing of multiple glocktop
 on multiple nodes.
* Create graphs for the following:
  - Top 10 glocks with waiters and graph the glocks waiter count over time.
  - pid -> glocks with that pid | count
  - glock -> pids
  - peak for highest number of holder/waiters for each glock
* Verify data in graph correct.

"""
import sys
import logging
import logging.handlers
import os
import os.path
from optparse import OptionParser, Option, SUPPRESS_HELP
from operator import itemgetter
from collections import OrderedDict

import glocktop_analyze
from glocktop_analyze.utilities import LogWriter
# Import logger that all files will use.
logger = LogWriter(glocktop_analyze.MAIN_LOGGER_NAME,
                   logging.INFO,
                   glocktop_analyze.MAIN_LOGGER_FORMAT,
                   disableConsoleLog=False)
from glocktop_analyze.utilities import ColorizeConsoleText, get_data_from_file, tableize, write_to_file
import glocktop_analyze.glocks_stats
from glocktop_analyze.gfs2_snapshot import GFS2Snapshot, DLMActivity
from glocktop_analyze.glock import Glock, GlockHolder, GlockObject
from glocktop_analyze.glocks_stats import GlocksStats, GlockStat
from glocktop_analyze.parsers.gfs2_snapshot import parse_gfs2_snapshot, process_gfs2_snapshot

from glocktop_analyze.stats import generate_graphs_by_glock_type, generate_graphs_by_glock_state
from glocktop_analyze.stats import generate_graphs_glocks_holder_waiter
from glocktop_analyze.stats import generate_bar_graphs, generate_graph_index_page


# #####################################################################
# Global vars:
# #####################################################################
VERSION_NUMBER = "0.1-5"

# ##############################################################################
# Get user selected options
# ##############################################################################
def __get_options(version) :
    cmd_parser = OptionParserExtended(version)
    cmd_parser.add_option("-d", "--debug",
                         action="store_true",
                         dest="enableDebugLogging",
                         help="enables debug logging",
                         default=False)
    cmd_parser.add_option("-q", "--quiet",
                         action="store_true",
                         dest="disableLoggingToConsole",
                         help="disables logging to console",
                         default=False)
    cmd_parser.add_option("-y", "--no_ask",
                        action="store_true",
                         dest="disableQuestions",
                         help="disables all questions and assumes yes",
                         default=False)
    cmd_parser.add_option("-p", "--path_to_filename",
                         action="store",
                         dest="path_to_src_file",
                         help="the path to the filename that will be parsed",
                         type="string",
                         metavar="<input filename>",
                         default="")
    cmd_parser.add_option("-o", "--path_to_output_dir",
                         action="store",
                         dest="path_to_output_dir",
                         help="the path to the directory where any files generated will be outputted",
                         type="string",
                         metavar="<input filename>",
                          default="/tmp/%s" %(cmd_parser.get_command_name().split(".")[0]))
    cmd_parser.add_option("-m", "--minimum_waiter_count",
                          action="store",
                          dest="minimum_waiter_count",
                          help="the minimum number of waiters for a glock",
                          type="int",
                          metavar="<minimum waiter count>",
                          default=1)
    cmd_parser.add_option("-n", "--gfs2_filesystem_name",
                          action="extend",
                          dest="gfs2_filesystem_names",
                          help="only analyze a particular gfs2 filesystem",
                          type="string",
                          metavar="<gfs2 filesystem name>",
                          default=[])
    cmd_parser.add_option("-E", "--ignore_ended_processes",
                        action="store_true",
                         dest="ignore_ended_processes",
                         help="ignore all glocks that contain 1 holder for ended process",
                         default=False)
    cmd_parser.add_option("-W", "--disable_show_waiters",
                          action="store_true",
                          dest="disable_show_waiters",
                          help="the waiters for the glocks are not displayed in the output",
                          default=False)
    cmd_parser.add_option("-S", "--disable_stats",
                          action="store_true",
                          dest="disable_stats",
                          help="do not print stats",
                          default=False)
    #cmd_parser.add_option("-C", "--disable_call_trace",
    #                      action="store_true",
    #                      dest="disable_call_trace",
    #                      help="do not print call traces for holder/waiters",
    #                      default=False)
    try:
        import pkgutil
        if (not pkgutil.find_loader('pygal') == None):
            # If pygal is not installed then this option will not be found.
            cmd_parser.add_option("-G", "--disable_graphs",
                                  action="store_true",
                                  dest="disable_graphs",
                                  help="do not generate graphs of stats",
                                  default=False)
    except (ImportError, NameError):
        message = "Failed to find pygal. The python-pygal package needs to be installed."
        logging.getLogger(MAIN_LOGGER_NAME).error(message)

    cmd_parser.add_option("-g", "--find_glock",
                          action="store",
                          dest="glock_inode",
                          help="a glock hexadecimal number to search for",
                          type="string",
                          metavar="0x<glock number>",
                          default="")
    cmd_parser.add_option("-t", "--find_glock_type",
                          action="store",
                          dest="glock_type",
                          help="a glock type to search for (requires glock number (-g))",
                          type="int",
                          metavar="<glock type>",
                          default=None)

 # Get the options and return the result.
    (cmdLine_opts, cmdLine_args) = cmd_parser.parse_args()
    return (cmdLine_opts, cmdLine_args)

# ##############################################################################
# OptParse classes for commandline options
# ##############################################################################
class OptionParserExtended(OptionParser):
    def __init__(self, version) :
        self.__command_name = os.path.basename(sys.argv[0])
        OptionParser.__init__(self, option_class=ExtendOption,
                              version="%s %s\n" %(self.__command_name, version),
                              description="%s \n"%(self.__command_name))

    def get_command_name(self):
        return self.__command_name
    def print_help(self):
        self.print_version()
        examples_message = "\n"
        OptionParser.print_help(self)
        #print examples_message

class ExtendOption (Option):
    ACTIONS = Option.ACTIONS + ("extend",)
    STORE_ACTIONS = Option.STORE_ACTIONS + ("extend",)
    TYPED_ACTIONS = Option.TYPED_ACTIONS + ("extend",)

    def take_action(self, action, dest, opt, value, values, parser):
        if (action == "extend") :
            valueList = []
            try:
                for v in value.split(","):
                    # Need to add code for dealing with paths if there is option for paths.
                    newValue = value.strip().rstrip()
                    if (len(newValue) > 0):
                        valueList.append(newValue)
            except:
                pass
            else:
                values.ensure_value(dest, []).extend(valueList)
        else:
            Option.take_action(self, action, dest, opt, value, values, parser)

# ###############################################################################
# Main Function
# ###############################################################################
if __name__ == "__main__":
    try:
        # #######################################################################
        # Get the options from the commandline.
        # #######################################################################
        (cmdline_opts, cmdline_args) = __get_options(VERSION_NUMBER)

        # #######################################################################
        # Set the logging levels.
        # #######################################################################
        if ((cmdline_opts.enableDebugLogging) and (not cmdline_opts.disableLoggingToConsole)):
            logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).setLevel(logging.DEBUG)
            logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).debug("Debugging has been enabled.")
        # #######################################################################
        # Validate input
        # #######################################################################
        if (not cmdline_opts.path_to_src_file):
            logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error("A path to a file (-p) to be analyzed is required.")
            sys.exit(1)
        if (not os.path.exists(cmdline_opts.path_to_src_file)):
            message ="The file does not exist: %s" %(cmdline_opts.path_to_src_file)
            logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error(message)
            sys.exit(1)
        if (not cmdline_opts.glock_type == None):
            if (not (0 < cmdline_opts.glock_type < 10)):
                logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error("The glock type (-G) must be an integer between 1 - 9.")
                sys.exit(1)
        if (not cmdline_opts.minimum_waiter_count > 0):
            logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error("The minimum holder count for a glock (-m) must be a positive integer.")
            sys.exit(1)

        glock_inode = ""
        if (cmdline_opts.glock_inode):
            try:
                if (cmdline_opts.glock_inode.startswith("0x")):
                    int("%s" %(cmdline_opts.glock_inode), 16)
                else:
                    int("0x%s" %(cmdline_opts.glock_inode), 16)
            except ValueError:
                logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error("The glock number (-g) must be a hexadecimal number.")
                sys.exit(1)
            except TypeError:
                logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error("The glock number (-g) must be a hexadecimal number.")
                sys.exit(1)

        # #######################################################################
        # Run main
        # #######################################################################
        message ="The file will be analyzed: %s" %(cmdline_opts.path_to_src_file)
        logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).debug(message)
        # Get the data as a list of lines
        lines = get_data_from_file(cmdline_opts.path_to_src_file)

        #All the snapshots for all the filesystems.
        snapshots = []
        # The glock that will have a container for all the lines associated with
        # the glock.
        gfs2_snapshot = None
        # The lines that are related to this snapshot of the
        # filesystem. Including glocks, waiters, etc.
        snapshot_lines = []
        for line in lines:
            # @, G, H, I, R, B, U, C, S
            if ((line.startswith("@")) or (not len(line) > 0)):
                if (not gfs2_snapshot == None):
                    # Process any previous snapshot lines before starting a
                    # new one. All the glocks, holder/waiters, etc.
                    if ((not cmdline_opts.gfs2_filesystem_names) or
                        (gfs2_snapshot.get_filesystem_name().strip() in cmdline_opts.gfs2_filesystem_names)):
                        process_gfs2_snapshot(gfs2_snapshot, snapshot_lines)
                        snapshots.append(gfs2_snapshot)
                # Process the new snapshot
                gfs2_snapshot = parse_gfs2_snapshot(line, cmdline_opts.ignore_ended_processes)
                snapshot_lines = []
            else:
                snapshot_lines.append(line)
        # Process any remaining items
        if (not gfs2_snapshot == None):
            if ((not cmdline_opts.gfs2_filesystem_names) or
                (gfs2_snapshot.get_filesystem_name().strip() in cmdline_opts.gfs2_filesystem_names)):
                process_gfs2_snapshot(gfs2_snapshot, snapshot_lines)
                snapshots.append(gfs2_snapshot)

        # #######################################################################
        # Analyze the data
        # #######################################################################
        # Print summary of data analyzed
        glocktop_summary_console = ""
        glocktop_summary_file = ""
        hostname = ""
        for snapshot in snapshots:
            hostname = snapshot.get_hostname()
            current_summary = ""
            glocks = []
            if (cmdline_opts.glock_inode):
                # Find particular glocks.
                glocks = snapshot.find_glock(cmdline_opts.glock_type, cmdline_opts.glock_inode.replace("0x", ""))
            else:
                glocks = snapshot.get_glocks()

            for glock in glocks:
                glock_holders = glock.get_holders()
                if (len(glock_holders) >= cmdline_opts.minimum_waiter_count):
                    current_summary += "  %s\n" %(glock)
                    if (not cmdline_opts.disable_show_waiters):
                        for holder in glock_holders:
                            current_summary += "    %s\n" %(holder)
                        if (not glock.get_glock_object() == None):
                            current_summary += "    %s\n" %(glock.get_glock_object())
            if (current_summary):
                glocktop_summary_console += "%s\n%s\n" %(ColorizeConsoleText.red(str(snapshot)), current_summary)
                glocktop_summary_file += "%s\n%s\n" %(str(snapshot), current_summary)

        print "%s\n" %(glocktop_summary_console.rstrip())
        # The path to directory where all files written for this host will be
        # written.
        path_to_output_dir = os.path.join(cmdline_opts.path_to_output_dir, hostname)

        path_to_glocktop_summary_file = os.path.join(path_to_output_dir, "glocktop_summary.txt")
        if (not write_to_file(path_to_glocktop_summary_file, glocktop_summary_file,
                              append_to_file=False, create_file=True)):
            message = "An error occurred writing the glocktop summary file: %s" %(path_to_glocktop_summary_file)
            logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error(message)

        # #######################################################################
        # Gather, print, and graph  stats
        # #######################################################################
        if (not cmdline_opts.disable_stats):
            # Print or write data gathered from the lines that started with "S"
            # for peroidic glock stats.

            from glocktop_analyze.stats.glocks_stats import GSStats
            from glocktop_analyze.stats.filesystems import Filesystems
            from glocktop_analyze.stats.glocks_high_demote_seconds import GlocksHighDemoteSeconds

            gsstats_stats = GSStats(snapshots, "Glocks Stats")
            gsstats_stats.analyze()
            gsstats_stats.console()
            gsstats_stats.write(path_to_output_dir)

            filesystems_stats = Filesystems(snapshots, "Filesystem Stats")
            filesystems_stats.analyze()
            filesystems_stats.console()
            filesystems_stats.write(path_to_output_dir)

            glocks_high_demote_secs_stats = GlocksHighDemoteSeconds(snapshots, "Glocks with High Demote Seconds")
            glocks_high_demote_secs_stats.analyze()
            glocks_high_demote_secs_stats.console()
            glocks_high_demote_secs_stats.write(path_to_output_dir)

            # Do various stats on the snapshots.
            #
            # The number of times that a glock appear in a snapshot for a
            # filesystem.
            glocks_appeared_in_snapshots = {}
            # The number of holders and waiters including the time taken for
            # each snapshot it appeared in.
            glocks_holder_waiters_by_date = {}
            # In some instances the unique key will be
            # "filesystem_name-glock_type/glock_inode". For example:
            # gfs2payroll-4/42ff2. Then for printing the filesystem and glock
            # info could be parsed out.
            for snapshot in snapshots:
                filesystem_name = snapshot.get_filesystem_name()
                # Get glock stats
                for glock in snapshot.get_glocks():
                    # Unique key <filename_name>-<glock_type>/<glock_inode>
                    glock_type_inode = "%s-%s/%s" %(filesystem_name, glock.get_type(), glock.get_inode())
                    if (glocks_appeared_in_snapshots.has_key(glock_type_inode)):
                        glocks_appeared_in_snapshots[glock_type_inode] = glocks_appeared_in_snapshots.get(glock_type_inode) + 1
                        dt_holder_waiter_count = (snapshot.get_date_time(), len(glock.get_holders()))
                        glocks_holder_waiters_by_date[glock_type_inode] += [dt_holder_waiter_count]
                    else:
                        glocks_appeared_in_snapshots[glock_type_inode] = 1
                        dt_holder_waiter_count = (snapshot.get_date_time(), len(glock.get_holders()))
                        glocks_holder_waiters_by_date[glock_type_inode] = [dt_holder_waiter_count]
            # Print glock stats
            path_to_glocktop_stats_file = os.path.join(path_to_output_dir, "glocktop_stats.txt")
            table = []
            for pair in sorted(glocks_appeared_in_snapshots.items(), key=itemgetter(1), reverse=True):
                # Only include if there is more than one waiter.
                if (pair[1] > 1):
                    table.append([pair[0].rsplit("-")[0], pair[0].rsplit("-")[1], pair[1]])
            ftable = tableize(table, ["Filesystem Name", "Glock Type/Glocks Inode", "Found in snapshot"])
            if (len(ftable) > 0):
                print ftable
            ftable = tableize(table, ["Filesystem Name", "Glock Type/Glocks Inode", "Found in snapshots"], colorize=False)
            if (len(ftable) > 0):
                if (not write_to_file(path_to_glocktop_stats_file, "%s \n" %(ftable),
                                      append_to_file=True, create_file=True)):
                    message = "An error occurred writing the glocktop stats file: %s" %(path_to_glocktop_stats_file)
                    logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).debug(message)

        # #######################################################################
        # Create graphs
        # #######################################################################
        try:
            # svg does better charts. png support requires the python files:
            # lxml, cairosvg, tinycss, cssselect
            enable_png_format=False
            if (not cmdline_opts.disable_graphs):
                # Graph the glocks stats and glock types
                message = "The graphs for the glocks stats will be generated."
                logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).debug(message)
                # Sort all the snapshots into filesystem bins.
                snapshots_by_filesystem = {}
                for snapshot in snapshots:
                    glocks_stats = snapshot.get_glocks_stats()
                    if (not glocks_stats == None):
                        if (snapshots_by_filesystem.has_key(snapshot.get_filesystem_name())):
                            snapshots_by_filesystem[snapshot.get_filesystem_name()].append(snapshot)
                        else:
                            snapshots_by_filesystem[snapshot.get_filesystem_name()] = [snapshot]
                for filesystem_name in snapshots_by_filesystem:
                    generate_graphs_by_glock_type(os.path.join(path_to_output_dir, filesystem_name),
                                                  snapshots_by_filesystem.get(filesystem_name),
                                                  format_png=enable_png_format)
                for filesystem_name in snapshots_by_filesystem:
                    generate_graphs_by_glock_state(os.path.join(path_to_output_dir, filesystem_name),
                                                   snapshots_by_filesystem.get(filesystem_name),
                                                   format_png=enable_png_format)

                # Graph the glocks number of holders and waiters over time.
                message = "Generating the graphs for glock's holder+waiter count over time."
                logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).debug(message)
                # Get the date/time of all the snapshots bor each filesystems.
                filesystem_snapshot_dt = {}
                for snapshot in snapshots:
                    filesystem_name = snapshot.get_filesystem_name()
                    # Get filesystem stats
                    if (filesystem_snapshot_dt.has_key(filesystem_name)):
                        filesystem_snapshot_dt[filesystem_name].append(snapshot.get_date_time())
                    else:
                        filesystem_snapshot_dt[filesystem_name] = [snapshot.get_date_time()]

                glocks_in_snapshots = {}
                for pair in sorted(glocks_appeared_in_snapshots.items(), key=itemgetter(1), reverse=True):
                    # Only include if there is more than one waiter.
                    if (pair[1] > 1):
                        filesystem_name = pair[0].rsplit("-")[0]
                        if (not glocks_in_snapshots.has_key(filesystem_name)):
                            glocks_in_snapshots[filesystem_name] = []
                            glocks_in_snapshots.get(filesystem_name).append([])
                            glocks_in_snapshots.get(filesystem_name).append([])
                        glocks_in_snapshots.get(filesystem_name)[0].append(pair[0].rsplit("-")[1])
                        glocks_in_snapshots.get(filesystem_name)[1].append(pair[1])

                # Find glocks that had more than one holder+waiters.
                for filesystem_name in glocks_in_snapshots.keys():
                    glocks_holder_waiters_counter = {}
                    for gkey in glocks_holder_waiters_by_date.keys():
                        hw_count = 0
                        if (gkey.startswith(filesystem_name)):
                            for gtuple in glocks_holder_waiters_by_date.get(gkey):
                                hw_count += gtuple[1]
                        if (hw_count > 1):
                            glocks_holder_waiters_counter[gkey] = hw_count

                    # Only graph the top 10 glocks with highest holder+waiter count.
                    max_glocks_to_graph = 10
                    glocks_highest_count = {}
                    index = 1
                    for t in reversed(OrderedDict(sorted(glocks_holder_waiters_counter.items(), key=lambda t: t[1]))):
                        if (index > max_glocks_to_graph):
                            try:
                                del glocks_holder_waiters_counter[t]
                            except KeyError:
                                pass
                        index += 1
                    # Map only glocks that had more than 1 holder+waiter so the possible items to graph is lower.
                    glocks_to_graph = {key.rsplit("-")[1]: glocks_holder_waiters_by_date[key] for key in glocks_holder_waiters_by_date if key in glocks_holder_waiters_counter.keys()}
                    generate_graphs_glocks_holder_waiter(os.path.join(path_to_output_dir, filesystem_name),
                                                         glocks_to_graph,
                                                         filesystem_snapshot_dt[filesystem_name], format_png=enable_png_format)
                message = "The graphs were to the directory: %s" %(path_to_output_dir)
                logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).info(message)
        except AttributeError:
            # Graphing must be disabled since option does not exists.
            pass

    except KeyboardInterrupt:
        print ""
        message =  "This script will exit since control-c was executed by end user."
        logging.getLogger(glocktop_analyze.MAIN_LOGGER_NAME).error(message)
        sys.exit(1)
    # #######################################################################
    # Exit the application with zero exit code since we cleanly exited.
    # #######################################################################
    sys.exit()
